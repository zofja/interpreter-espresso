module Evaluator where

-- Haskell module generated by the BNF converter
import           AbsEspresso
import           Control.Monad.Except
import           Control.Monad.IO.Class
import           Control.Monad.Reader
import           Control.Monad.State.Lazy
import           Data.Map
import qualified Data.Map                 as Map
import           Data.Maybe               (maybeToList)
import           Data.Void                (Void)
import           ErrM

type Store = Map Loc Value

type Env = Map Ident Loc

type Result a = ReaderT Env (StateT Store (ExceptT (Exception ExceptionValue) IO)) a

type ArgIdentExpr = (Ident, Expr)

type LocMaybeValue = (Loc, Maybe Value)

type Loc = Int

data Value
  = FunVal FunDef
  | IntVal Integer
  | StrVal String
  | BoolVal Bool
  | VoidVal
  | LambdaVal [Arg] Block Env
  deriving (Eq, Ord, Read)

instance Show (Value) where
  show (FunVal f)                 = "function"
  show (IntVal i)                 = show i
  show (StrVal s)                 = s
  show (BoolVal b)                = show b
  show (VoidVal)                  = "void"
  show (LambdaVal args block env) = "lambda"

data ExceptionValue
  = ExceptionIdent Ident
  | ExceptionValue Value
  deriving (Eq, Ord, Show, Read)

data Exception msg
  = ErrorNoLocation msg
  | ErrorNoValue msg
  | ErrorFunctionRedefinition msg
  | ErrorNotComparableValue msg
  | ErrorNotAnInteger msg
  | ErrorNotABoolean msg
  | ErrorNotAString msg
  | ErrorNotAFunction msg
  | ErrorListsNotEqualLen
  | ErrorDivisionByZero
  deriving (Eq, Ord, Show, Read)

mainIdent = Ident "main"

evalProgram :: Program -> Result Value
evalProgram (Program []) = do
  maybeValue <- maybeLookupLocationAndValue mainIdent
  case maybeValue of
    Just f@(FunVal _) -> evalFunVal f
    _                 -> throwErrorNoValue mainIdent
evalProgram (Program (f@(FunDef _ ident _ _):funs)) = do
  loc <- alloc
  evalFunDef f loc
  local (Map.insert ident loc) (evalProgram $ Program funs)

evalFunDef :: FunDef -> Loc -> Result ()
evalFunDef f@(FunDef _ ident _ _) loc = do
  maybeLoc <- lookupLocation ident
  case maybeLoc of
    Just _  -> throwErrorFunctionRedefinition ident
    Nothing -> insertToStore loc (FunVal f)

evalFunVal :: Value -> Result Value
evalFunVal (FunVal (FunDef type_ ident args block)) = evalBlock block >>= maybe (return VoidVal) (return)
evalFunVal l@(LambdaVal args block env) = local (\_ -> env) (evalBlock block) >>= maybe (return VoidVal) (return)

evalBlock :: Block -> Result (Maybe Value)
evalBlock (Block stmts) = evalStmts stmts

evalStmts :: [Stmt] -> Result (Maybe Value)
evalStmts [] = return Nothing
evalStmts (s:stmts) = do
  case s of
    FunStmt f@(FunDef _ ident _ _) -> evalFunStmt f >>= \loc -> local (Map.insert ident loc) contEval
    Init _ ident expr -> evalInit expr >>= \loc -> local (Map.insert ident loc) contEval
    BStmt block -> evalBlock block >>= maybe (evalStmts stmts) (return . Just)
    CondElse expr s1 s2 -> evalCond expr s1 (Just s2) >>= maybe (contEval) (return . Just)
    Cond expr stmt -> evalCond expr stmt Nothing >>= maybe (contEval) (return . Just)
    For _ ident e1 e2 block -> evalFor ident block e1 e2 >>= maybe (contEval) (return . Just)
    While expr stmt -> evalWhile expr stmt >>= maybe (contEval) (return . Just)
    Ret expr -> evalExpr expr >>= return . Just
    VRet -> return $ Just VoidVal
    Ass ident expr -> evalAss ident expr >> contEval
    Incr ident -> evalAddOpStmt ident Plus >> contEval
    Decr ident -> evalAddOpStmt ident Minus >> contEval
    Print expr -> evalPrint expr >> contEval
    SExp expr -> evalExpr expr >> contEval
    Empty -> contEval
  where
    contEval = evalStmts stmts

evalFunStmt :: FunDef -> Result Loc
evalFunStmt f = do
  loc <- alloc
  evalFunDef f loc
  return loc

evalInit :: Expr -> Result Loc
evalInit expr = do
  loc <- alloc
  evalExprAndInsertToStore expr loc
  return loc

evalAss :: Ident -> Expr -> Result ()
evalAss ident expr = lookupLocation ident >>= maybe (throwErrorNoLocation ident) (evalExprAndInsertToStore expr)

evalCond :: Expr -> Stmt -> Maybe Stmt -> Result (Maybe Value)
evalCond expr stmt maybeStmt = do
  cond <- evalCondExpr expr
  case cond of
    True  -> evalStmts [stmt]
    False -> evalStmts $ maybeToList maybeStmt

evalCondExpr :: Expr -> Result Bool
evalCondExpr expr = do
  val <- evalExpr expr
  case val of
    (BoolVal b) -> return b
    _           -> throwErrorNotABoolean val

evalAddOpStmt :: Ident -> AddOp -> Result ()
evalAddOpStmt ident addop = do
  maybeLoc <- lookupLocation ident
  case maybeLoc of
    Just loc -> do
      val <- lookupValue loc
      case val of
        Just val -> do
          modifiedVal <- evalAddOp val addop (IntVal 1)
          insertToStore loc modifiedVal
        Nothing -> throwErrorNoValue ident
    Nothing -> throwErrorNoLocation ident

evalWhile :: Expr -> Stmt -> Result (Maybe Value)
evalWhile expr stmt = do
  val <- evalExpr expr
  case val of
    (BoolVal False) -> return Nothing
    (BoolVal True) -> do
      maybeValue <- evalStmts [stmt]
      case maybeValue of
        Just returnValue -> return $ Just returnValue
        Nothing          -> evalWhile expr stmt
    _ -> throwErrorNotABoolean val

evalFor :: Ident -> Block -> Expr -> Expr -> Result (Maybe Value)
evalFor ident block e1 e2 = do
  val1 <- evalExpr e1
  val2 <- evalExpr e2
  case (val1, val2) of
    (i@(IntVal _), limit@(IntVal _)) -> do
      loc <- alloc
      insertToStore loc i
      local (Map.insert ident loc) (evalForBlock loc block i limit)
    ((IntVal _), val2) -> throwErrorNotAnInteger val2
    (val1, _) -> throwErrorNotAnInteger val1

evalForBlock :: Loc -> Block -> Value -> Value -> Result (Maybe Value)
evalForBlock loc block i limit = do
  cond <- evalRelOp i LE limit
  case cond of
    False -> return Nothing
    True -> do
      maybeValue <- evalBlock block
      i <- updateForCondition loc i
      case maybeValue of
        Just returnValue -> return $ Just returnValue
        Nothing          -> evalForBlock loc block i limit

updateForCondition :: Loc -> Value -> Result Value
updateForCondition loc (IntVal i) = do
  let updatedValue = IntVal $ i + 1
   in do insertToStore loc updatedValue
         return $ updatedValue

evalPrint :: Expr -> Result ()
evalPrint expr = evalExpr expr >>= liftIO . putStrLn . show

evalExprAndInsertToStore :: Expr -> Loc -> Result ()
evalExprAndInsertToStore expr loc = evalExpr expr >>= insertToStore loc

evalExpr :: Expr -> Result Value
evalExpr expr = do
  case expr of
    ELitInt integer      -> return $ IntVal integer
    ELitTrue             -> return $ BoolVal True
    ELitFalse            -> return $ BoolVal False
    EString string       -> return $ StrVal string
    ELambda args block   -> ask >>= return . LambdaVal args block
    EVar ident           -> lookupLocAndValue ident
    EApp ident exprs     -> lookupLocAndValue ident >>= evalEApp exprs
    Neg expr             -> evalExpr expr >>= evalNeg
    Not expr             -> evalExpr expr >>= evalNot
    EMul e1 mulop e2     -> evalBinaryOp e1 mulop e2 evalMulOp
    EAdd e1 addop e2     -> evalBinaryOp e1 addop e2 evalAddOp
    ELogic e1 logicop e2 -> evalBinaryOp e1 logicop e2 evalLogicOp
    ERel e1 relop e2     -> evalERel e1 relop e2

evalEApp :: [Expr] -> Value -> Result Value
evalEApp exprs f = do
  case f of
    (FunVal (FunDef t ident args block)) -> evalApp f args exprs
    (LambdaVal args block env)           -> evalApp f args exprs
    _                                    -> throwErrorNotAFunction f

evalApp :: Value -> [Arg] -> [Expr] -> Result Value
evalApp f args exprs = do
  assertListsEqualLen idents exprs
  evalAppVal f $ zip idents exprs
  where
    idents = Prelude.map (\(Arg _ i) -> i) args

evalAppVal :: Value -> [ArgIdentExpr] -> Result Value
evalAppVal f [] = evalFunVal f
evalAppVal l@(LambdaVal lambdaArgs block env) ((ident, expr):args) = do
  loc <- alloc
  evalExprAndInsertToStore expr loc
  let newEnv = Map.insert ident loc env
   in do evalAppVal (LambdaVal lambdaArgs block newEnv) args
evalAppVal f@(FunVal fun) ((ident, expr):args) = do
  loc <- alloc
  evalExprAndInsertToStore expr loc
  local (Map.insert ident loc) (evalAppVal f args)

evalNeg :: Value -> Result Value
evalNeg (IntVal i) = return $ IntVal $ negate i
evalNeg val        = throwErrorNotAnInteger val

evalNot :: Value -> Result Value
evalNot (BoolVal b) = return $ BoolVal $ not b
evalNot val         = throwErrorNotABoolean val

evalLogicOp :: Value -> LogicOp -> Value -> Result Value
evalLogicOp (BoolVal val1) op (BoolVal val2) = do
  case op of
    And -> return $ BoolVal $ val1 && val2
    Or  -> return $ BoolVal $ val1 || val2

evalBinaryOp :: Expr -> a -> Expr -> (Value -> a -> Value -> Result Value) -> Result Value
evalBinaryOp e1 op e2 f = do
  val1 <- evalExpr e1
  val2 <- evalExpr e2
  f val1 op val2

evalERel :: Expr -> RelOp -> Expr -> Result Value
evalERel e1 relop e2 = do
  val1 <- evalExpr e1
  val2 <- evalExpr e2
  res <- evalRelOp val1 relop val2
  return $ BoolVal res

evalMulOp :: Value -> MulOp -> Value -> Result Value
evalMulOp (IntVal val1) Div (IntVal 0) = throwError $ ErrorDivisionByZero
evalMulOp (IntVal val1) mulop (IntVal val2) =
  case mulop of
    Times -> return $ IntVal $ val1 * val2
    Div   -> return $ IntVal $ div val1 val2
    Mod   -> return $ IntVal $ mod val1 val2
evalMulOp (IntVal _) _ val2 = throwErrorNotAnInteger val2
evalMulOp val1 _ _ = throwErrorNotAnInteger val1

evalAddOp :: Value -> AddOp -> Value -> Result Value
evalAddOp (IntVal val1) addop (IntVal val2) =
  case addop of
    Plus  -> return $ IntVal $ val1 + val2
    Minus -> return $ IntVal $ val1 - val2
evalAddOp (IntVal _) _ val2 = throwErrorNotAnInteger val2
evalAddOp val1 _ _ = throwErrorNotAnInteger val1

evalRelOp :: Value -> RelOp -> Value -> Result Bool
evalRelOp (IntVal val1) relop (IntVal val2) = return $ evalRelCompOp val1 relop val2
evalRelOp val1 relop val2 = evalRelEqOp val1 relop val2

evalRelCompOp :: Integer -> RelOp -> Integer -> Bool
evalRelCompOp val1 relop val2 = do
  case relop of
    LTH -> val1 < val2
    LE  -> val1 <= val2
    GTH -> val1 > val2
    GE  -> val1 >= val2
    EQU -> val1 == val2
    NE  -> val1 /= val2

evalRelEqOp :: Value -> RelOp -> Value -> Result Bool
evalRelEqOp (StrVal val1) relop (StrVal val2) = do
  case relop of
    EQU -> return $ val1 == val2
    NE  -> return $ val1 /= val2
evalRelEqOp (StrVal _) _ val2 = throwErrorNotAString val2
evalRelEqOp (BoolVal val1) relop (BoolVal val2) = do
  case relop of
    EQU -> return $ val1 == val2
    NE  -> return $ val1 /= val2
evalRelEqOp (BoolVal _) _ val2 = throwErrorNotABoolean val2
evalRelEqOp val1 _ _ = throwErrorNotComparableValue val1

-- Helper functions
alloc :: Result Loc
alloc = get >>= return . size

insertToStore :: Loc -> Value -> Result ()
insertToStore loc val = get >>= put . Map.insert loc val

lookupLocation :: Ident -> Result (Maybe Loc)
lookupLocation ident = ask >>= return . Map.lookup ident

lookupValue :: Loc -> Result (Maybe Value)
lookupValue loc = get >>= return . Map.lookup loc

maybeLookupLocationAndValue :: Ident -> Result (Maybe Value)
maybeLookupLocationAndValue ident = do
  maybeLoc <- lookupLocation ident
  case maybeLoc of
    Just loc -> do
      store <- get
      return $ Map.lookup loc store
    Nothing -> throwErrorNoLocation ident

lookupLocAndValue :: Ident -> Result Value
lookupLocAndValue ident = do
  maybeLoc <- lookupLocation ident
  case maybeLoc of
    Just loc -> do
      store <- get
      case (Map.lookup loc store) of
        Just val -> return val
        Nothing  -> throwErrorNoValue ident
    Nothing -> throwErrorNoLocation ident

assertListsEqualLen :: (Show a, Show b) => [a] -> [b] -> Result ()
assertListsEqualLen l1 l2 =
  case (length l1 == length l2) of
    True  -> return ()
    False -> throwError $ ErrorListsNotEqualLen

throwErrorFunctionRedefinition :: Ident -> Result a
throwErrorFunctionRedefinition ident = throwError $ ErrorFunctionRedefinition $ ExceptionIdent ident

throwErrorNoLocation :: Ident -> Result a
throwErrorNoLocation ident = throwError $ ErrorNoLocation $ ExceptionIdent ident

throwErrorNoValue :: Ident -> Result a
throwErrorNoValue ident = throwError $ ErrorNoValue $ ExceptionIdent ident

throwErrorNotAnInteger :: Value -> Result a
throwErrorNotAnInteger val = throwError $ ErrorNotAnInteger $ ExceptionValue val

throwErrorNotABoolean :: Value -> Result a
throwErrorNotABoolean val = throwError $ ErrorNotABoolean $ ExceptionValue val

throwErrorNotAString :: Value -> Result a
throwErrorNotAString val = throwError $ ErrorNotAString $ ExceptionValue val

throwErrorNotAFunction :: Value -> Result a
throwErrorNotAFunction val = throwError $ ErrorNotAFunction $ ExceptionValue val

throwErrorNotComparableValue :: Value -> Result a
throwErrorNotComparableValue val = throwError $ ErrorNotComparableValue $ ExceptionValue val
